{
  "address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_bytes",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_start",
          "type": "uint256"
        }
      ],
      "name": "_le_bytes_get_uint32",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32[8]",
                  "name": "chaining_value",
                  "type": "uint32[8]"
                },
                {
                  "internalType": "uint64",
                  "name": "chunk_counter",
                  "type": "uint64"
                },
                {
                  "internalType": "bytes",
                  "name": "block_bytes",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "block_len",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blocks_compressed",
                  "type": "uint256"
                },
                {
                  "internalType": "uint32",
                  "name": "flags",
                  "type": "uint32"
                }
              ],
              "internalType": "struct Blake3SolTest.ChunkState",
              "name": "chunk_state",
              "type": "tuple"
            },
            {
              "internalType": "uint32[8]",
              "name": "key_words",
              "type": "uint32[8]"
            },
            {
              "internalType": "uint32[8][54]",
              "name": "cv_stack",
              "type": "uint32[8][54]"
            },
            {
              "internalType": "uint8",
              "name": "cv_stack_len",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "flags",
              "type": "uint32"
            }
          ],
          "internalType": "struct Blake3SolTest.Hasher",
          "name": "self",
          "type": "tuple"
        }
      ],
      "name": "finalize",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "context",
          "type": "bytes"
        }
      ],
      "name": "new_derive_key",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32[8]",
                  "name": "chaining_value",
                  "type": "uint32[8]"
                },
                {
                  "internalType": "uint64",
                  "name": "chunk_counter",
                  "type": "uint64"
                },
                {
                  "internalType": "bytes",
                  "name": "block_bytes",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "block_len",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blocks_compressed",
                  "type": "uint256"
                },
                {
                  "internalType": "uint32",
                  "name": "flags",
                  "type": "uint32"
                }
              ],
              "internalType": "struct Blake3SolTest.ChunkState",
              "name": "chunk_state",
              "type": "tuple"
            },
            {
              "internalType": "uint32[8]",
              "name": "key_words",
              "type": "uint32[8]"
            },
            {
              "internalType": "uint32[8][54]",
              "name": "cv_stack",
              "type": "uint32[8][54]"
            },
            {
              "internalType": "uint8",
              "name": "cv_stack_len",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "flags",
              "type": "uint32"
            }
          ],
          "internalType": "struct Blake3SolTest.Hasher",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "new_hasher",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32[8]",
                  "name": "chaining_value",
                  "type": "uint32[8]"
                },
                {
                  "internalType": "uint64",
                  "name": "chunk_counter",
                  "type": "uint64"
                },
                {
                  "internalType": "bytes",
                  "name": "block_bytes",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "block_len",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blocks_compressed",
                  "type": "uint256"
                },
                {
                  "internalType": "uint32",
                  "name": "flags",
                  "type": "uint32"
                }
              ],
              "internalType": "struct Blake3SolTest.ChunkState",
              "name": "chunk_state",
              "type": "tuple"
            },
            {
              "internalType": "uint32[8]",
              "name": "key_words",
              "type": "uint32[8]"
            },
            {
              "internalType": "uint32[8][54]",
              "name": "cv_stack",
              "type": "uint32[8][54]"
            },
            {
              "internalType": "uint8",
              "name": "cv_stack_len",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "flags",
              "type": "uint32"
            }
          ],
          "internalType": "struct Blake3SolTest.Hasher",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "key",
          "type": "bytes"
        }
      ],
      "name": "new_keyed",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32[8]",
                  "name": "chaining_value",
                  "type": "uint32[8]"
                },
                {
                  "internalType": "uint64",
                  "name": "chunk_counter",
                  "type": "uint64"
                },
                {
                  "internalType": "bytes",
                  "name": "block_bytes",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "block_len",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blocks_compressed",
                  "type": "uint256"
                },
                {
                  "internalType": "uint32",
                  "name": "flags",
                  "type": "uint32"
                }
              ],
              "internalType": "struct Blake3SolTest.ChunkState",
              "name": "chunk_state",
              "type": "tuple"
            },
            {
              "internalType": "uint32[8]",
              "name": "key_words",
              "type": "uint32[8]"
            },
            {
              "internalType": "uint32[8][54]",
              "name": "cv_stack",
              "type": "uint32[8][54]"
            },
            {
              "internalType": "uint8",
              "name": "cv_stack_len",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "flags",
              "type": "uint32"
            }
          ],
          "internalType": "struct Blake3SolTest.Hasher",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "test_hash",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "test_keyed_hash",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "test_keyed_hash_ten_times",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32[8]",
                  "name": "chaining_value",
                  "type": "uint32[8]"
                },
                {
                  "internalType": "uint64",
                  "name": "chunk_counter",
                  "type": "uint64"
                },
                {
                  "internalType": "bytes",
                  "name": "block_bytes",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "block_len",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blocks_compressed",
                  "type": "uint256"
                },
                {
                  "internalType": "uint32",
                  "name": "flags",
                  "type": "uint32"
                }
              ],
              "internalType": "struct Blake3SolTest.ChunkState",
              "name": "chunk_state",
              "type": "tuple"
            },
            {
              "internalType": "uint32[8]",
              "name": "key_words",
              "type": "uint32[8]"
            },
            {
              "internalType": "uint32[8][54]",
              "name": "cv_stack",
              "type": "uint32[8][54]"
            },
            {
              "internalType": "uint8",
              "name": "cv_stack_len",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "flags",
              "type": "uint32"
            }
          ],
          "internalType": "struct Blake3SolTest.Hasher",
          "name": "self",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "input",
          "type": "bytes"
        }
      ],
      "name": "update_hasher",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint32[8]",
                  "name": "chaining_value",
                  "type": "uint32[8]"
                },
                {
                  "internalType": "uint64",
                  "name": "chunk_counter",
                  "type": "uint64"
                },
                {
                  "internalType": "bytes",
                  "name": "block_bytes",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "block_len",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "blocks_compressed",
                  "type": "uint256"
                },
                {
                  "internalType": "uint32",
                  "name": "flags",
                  "type": "uint32"
                }
              ],
              "internalType": "struct Blake3SolTest.ChunkState",
              "name": "chunk_state",
              "type": "tuple"
            },
            {
              "internalType": "uint32[8]",
              "name": "key_words",
              "type": "uint32[8]"
            },
            {
              "internalType": "uint32[8][54]",
              "name": "cv_stack",
              "type": "uint32[8][54]"
            },
            {
              "internalType": "uint8",
              "name": "cv_stack_len",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "flags",
              "type": "uint32"
            }
          ],
          "internalType": "struct Blake3SolTest.Hasher",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x48e84324bb4817a1a9c8bc812486ce0629008a05439ad6938e17b4dbaade0f6c",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "transactionIndex": 0,
    "gasUsed": "1940721",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd1847dc2b797367644d73274dad77d5b1eaeaf40aad854a3664c624c34c04360",
    "transactionHash": "0x48e84324bb4817a1a9c8bc812486ce0629008a05439ad6938e17b4dbaade0f6c",
    "logs": [],
    "blockNumber": 1,
    "cumulativeGasUsed": "1940721",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "86c6642793b33757b2be51068a51c201",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_bytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"_le_bytes_get_uint32\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32[8]\",\"name\":\"chaining_value\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint64\",\"name\":\"chunk_counter\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"block_bytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"block_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocks_compressed\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.ChunkState\",\"name\":\"chunk_state\",\"type\":\"tuple\"},{\"internalType\":\"uint32[8]\",\"name\":\"key_words\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint32[8][54]\",\"name\":\"cv_stack\",\"type\":\"uint32[8][54]\"},{\"internalType\":\"uint8\",\"name\":\"cv_stack_len\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.Hasher\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"finalize\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"new_derive_key\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32[8]\",\"name\":\"chaining_value\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint64\",\"name\":\"chunk_counter\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"block_bytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"block_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocks_compressed\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.ChunkState\",\"name\":\"chunk_state\",\"type\":\"tuple\"},{\"internalType\":\"uint32[8]\",\"name\":\"key_words\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint32[8][54]\",\"name\":\"cv_stack\",\"type\":\"uint32[8][54]\"},{\"internalType\":\"uint8\",\"name\":\"cv_stack_len\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.Hasher\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"new_hasher\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32[8]\",\"name\":\"chaining_value\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint64\",\"name\":\"chunk_counter\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"block_bytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"block_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocks_compressed\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.ChunkState\",\"name\":\"chunk_state\",\"type\":\"tuple\"},{\"internalType\":\"uint32[8]\",\"name\":\"key_words\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint32[8][54]\",\"name\":\"cv_stack\",\"type\":\"uint32[8][54]\"},{\"internalType\":\"uint8\",\"name\":\"cv_stack_len\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.Hasher\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"}],\"name\":\"new_keyed\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32[8]\",\"name\":\"chaining_value\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint64\",\"name\":\"chunk_counter\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"block_bytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"block_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocks_compressed\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.ChunkState\",\"name\":\"chunk_state\",\"type\":\"tuple\"},{\"internalType\":\"uint32[8]\",\"name\":\"key_words\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint32[8][54]\",\"name\":\"cv_stack\",\"type\":\"uint32[8][54]\"},{\"internalType\":\"uint8\",\"name\":\"cv_stack_len\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.Hasher\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"test_hash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"test_keyed_hash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"test_keyed_hash_ten_times\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32[8]\",\"name\":\"chaining_value\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint64\",\"name\":\"chunk_counter\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"block_bytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"block_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocks_compressed\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.ChunkState\",\"name\":\"chunk_state\",\"type\":\"tuple\"},{\"internalType\":\"uint32[8]\",\"name\":\"key_words\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint32[8][54]\",\"name\":\"cv_stack\",\"type\":\"uint32[8][54]\"},{\"internalType\":\"uint8\",\"name\":\"cv_stack_len\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.Hasher\",\"name\":\"self\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"}],\"name\":\"update_hasher\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32[8]\",\"name\":\"chaining_value\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint64\",\"name\":\"chunk_counter\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"block_bytes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"block_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocks_compressed\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.ChunkState\",\"name\":\"chunk_state\",\"type\":\"tuple\"},{\"internalType\":\"uint32[8]\",\"name\":\"key_words\",\"type\":\"uint32[8]\"},{\"internalType\":\"uint32[8][54]\",\"name\":\"cv_stack\",\"type\":\"uint32[8][54]\"},{\"internalType\":\"uint8\",\"name\":\"cv_stack_len\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"flags\",\"type\":\"uint32\"}],\"internalType\":\"struct Blake3SolTest.Hasher\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"new_hasher()\":{\"notice\":\"Construct a new `Hasher` for the regular hash function.\"},\"new_keyed(bytes)\":{\"notice\":\"Construct a new `Hasher` for the keyed hash function.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Blake3SolTest.sol\":\"Blake3SolTest\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"contracts/Blake3SolTest.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n// import \\\"./Blake3Sol.sol\\\";\\r\\n\\r\\ncontract Blake3SolTest {\\r\\n    // using Blake3Sol for Blake3Sol.Hasher;\\r\\n      //type State is uint32[16];\\r\\n    //type usize is uint32;\\r\\n    uint256 constant BLOCK_LEN = 64;\\r\\n    uint32 constant OUT_LEN = 32;\\r\\n    uint32 constant CHUNK_LEN = 1024;\\r\\n\\r\\n    // Flag constants\\r\\n    uint32 constant CHUNK_START = 1 << 0;\\r\\n    uint32 constant CHUNK_END = 1 << 1;\\r\\n    uint32 constant PARENT = 1 << 2;\\r\\n    uint32 constant ROOT = 1 << 3;\\r\\n    uint32 constant KEYED_HASH = 1 << 4;\\r\\n    uint32 constant DERIVE_KEY_CONTEXT = 1 << 5;\\r\\n    uint32 constant DERIVE_KEY_MATERIAL = 1 << 6;\\r\\n\\r\\n    // Product of a ChunkState before deriving chain value\\r\\n    struct Output {\\r\\n        uint32[8] input_chaining_value;\\r\\n        uint32[16] block_words;\\r\\n        uint64 counter;\\r\\n        uint256 block_len;\\r\\n        uint32 flags;\\r\\n    }\\r\\n\\r\\n    struct ChunkState {\\r\\n        uint32[8] chaining_value;\\r\\n        uint64 chunk_counter;\\r\\n        // Has a max size of BLOCK_LEN\\r\\n        bytes block_bytes;\\r\\n        uint256 block_len;\\r\\n        uint256 blocks_compressed;\\r\\n        uint32 flags;\\r\\n    }\\r\\n\\r\\n    // An incremental hasher that can accept any number of writes.\\r\\n    struct Hasher {\\r\\n        ChunkState chunk_state;\\r\\n        uint32[8] key_words;\\r\\n        uint32[8][54] cv_stack; // Space for 54 subtree chaining values:\\r\\n        uint8 cv_stack_len;     // 2^54 * CHUNK_LEN = 2^64\\r\\n        uint32 flags;\\r\\n    }\\r\\n\\r\\n    function test_hash() public pure returns (bytes memory) {\\r\\n        Hasher memory hasher = new_hasher();\\r\\n\\r\\n        hasher = update_hasher(hasher, unicode\\\"hellohello?\\\");\\r\\n        bytes memory output = finalize(hasher);\\r\\n\\r\\n        return output;\\r\\n\\r\\n        // assertEq(\\r\\n        //     bytes32(output),\\r\\n        //     0x10e6acb2cfcc4bb07588ad5b8e85f6a13f19e24f3302826effd93ce1ebbece6e\\r\\n        // );\\r\\n    }\\r\\n\\r\\n    function test_keyed_hash() public pure returns (bytes memory) {\\r\\n        Hasher memory hasher  = new_keyed(unicode\\\"hellohello!\\\");\\r\\n\\r\\n        hasher = update_hasher(hasher, unicode\\\"hellohello?\\\");\\r\\n        bytes memory output = finalize(hasher);\\r\\n\\r\\n        return output;\\r\\n\\r\\n        // assertEq(\\r\\n        //     bytes32(output),\\r\\n        //     0x0edd7e645d2bc1bba1f323f6339a3d0448ec6b675991e8dc76d2396eb0dffca2\\r\\n        // );\\r\\n    }\\r\\n\\r\\n    function test_keyed_hash_ten_times() public pure returns (bytes memory) {\\r\\n        Hasher memory hasher  = new_keyed(unicode\\\"hellohello!\\\");\\r\\n        bytes memory output;\\r\\n\\r\\n        for (uint256 i = 0; i < 10; ++i) {\\r\\n            hasher = update_hasher(hasher, unicode\\\"hellohello?\\\");\\r\\n            output = finalize(hasher);\\r\\n        }\\r\\n\\r\\n        return output;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * This test works by levaraging the FFI provided by Foundry tools, but it also requires the\\r\\n    * bridge-differential-tests project to exist in the same folder as Blake3Sol and it must\\r\\n    * be compiled using `cargo build` before running the Solidity test. This test currently passes\\r\\n    * hashing ~50kb of data.\\r\\n    *\\r\\n    function test_big_hash_ffi() public {\\r\\n        string[] memory cmds = new string[](2);\\r\\n        cmds[0] = '../bridge-differential-tests/target/debug/bridge_differential_tests';\\r\\n        cmds[1] = '--big-hash';\\r\\n\\r\\n        bytes memory packedData = vm.ffi(cmds);\\r\\n        (bytes memory data, bytes32 dataHash) = abi.decode(packedData, (bytes, bytes32));\\r\\n\\r\\n        Blake3Sol.Hasher memory hasher = Blake3Sol.new_keyed(\\r\\n            abi.encodePacked(\\r\\n                bytes32(0xc811f2ef6eb6bd09fb973c747cbf349e682393ca4d8df88e5f0bcd564c10a84b)\\r\\n            )\\r\\n        );\\r\\n        hasher = hasher.update_hasher(data);\\r\\n        bytes memory bigHash = hasher.finalize();\\r\\n\\r\\n        assertEq(bytes32(bigHash), dataHash);\\r\\n    }\\r\\n    */\\r\\n\\r\\n    // INTERNAL FUNCTIONS\\r\\n\\r\\n      // This should remain constant but solidity doesn't support declaring it\\r\\n    // uint8[16] MSG_PERMUTATION = [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8];\\r\\n    // uint32[8] IV = [\\r\\n    //     0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\\r\\n    // ];\\r\\n    function _MSG_PERMUTATION() internal pure returns (uint8[16] memory) {\\r\\n        return [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8];\\r\\n    }\\r\\n\\r\\n    function _IV() internal pure returns (uint32[8] memory) {\\r\\n        return [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19];\\r\\n    }\\r\\n\\r\\n    // Mixing function G\\r\\n    function _g(\\r\\n        uint32[16] memory state,\\r\\n        uint32 a,\\r\\n        uint32 b,\\r\\n        uint32 c,\\r\\n        uint32 d,\\r\\n        uint32 mx,\\r\\n        uint32 my\\r\\n    ) internal pure {\\r\\n        unchecked {\\r\\n            state[a] = state[a] + state[b] + mx;\\r\\n            state[d] = _rotr(state[d] ^ state[a], 16);\\r\\n            state[c] = state[c] + state[d];\\r\\n            state[b] = _rotr(state[b] ^ state[c], 12);\\r\\n            state[a] = state[a] + state[b] + my;\\r\\n            state[d] = _rotr(state[d] ^ state[a], 8);\\r\\n            state[c] = state[c] + state[d];\\r\\n            state[b] = _rotr(state[b] ^ state[c], 7);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _round(uint32[16] memory state, uint32[16] memory m) internal pure {\\r\\n        // Mix the columns.\\r\\n        _g(state, 0, 4, 8, 12, m[0], m[1]);\\r\\n        _g(state, 1, 5, 9, 13, m[2], m[3]);\\r\\n        _g(state, 2, 6, 10, 14, m[4], m[5]);\\r\\n        _g(state, 3, 7, 11, 15, m[6], m[7]);\\r\\n\\r\\n        // Mix the diagonals.\\r\\n        _g(state, 0, 5, 10, 15, m[8], m[9]);\\r\\n        _g(state, 1, 6, 11, 12, m[10], m[11]);\\r\\n        _g(state, 2, 7, 8, 13, m[12], m[13]);\\r\\n        _g(state, 3, 4, 9, 14, m[14], m[15]);\\r\\n    }\\r\\n\\r\\n    function _permute(uint32[16] memory m) internal pure {\\r\\n        uint8[16] memory MSG_PERMUTATION = _MSG_PERMUTATION();\\r\\n        uint32[16] memory permuted;\\r\\n\\r\\n        for (uint256 i = 0; i < 16; ++i) {\\r\\n            permuted[i] = m[MSG_PERMUTATION[i]];\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < 16; ++i) {\\r\\n            m[i] = permuted[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _compress(\\r\\n        uint32[8] memory chaining_value,\\r\\n        uint32[16] memory block_words_ref,\\r\\n        uint64 counter,\\r\\n        uint256 block_len,\\r\\n        uint32 flags\\r\\n    ) internal pure returns (uint32[16] memory) {\\r\\n        uint32[8] memory IV = _IV();\\r\\n        uint32[16] memory block_words;\\r\\n        for (uint256 i = 0; i < 16; ++i) {\\r\\n            block_words[i] = block_words_ref[i];\\r\\n        }\\r\\n\\r\\n        uint32[16] memory state = [\\r\\n            chaining_value[0],\\r\\n            chaining_value[1],\\r\\n            chaining_value[2],\\r\\n            chaining_value[3],\\r\\n            chaining_value[4],\\r\\n            chaining_value[5],\\r\\n            chaining_value[6],\\r\\n            chaining_value[7],\\r\\n            IV[0],\\r\\n            IV[1],\\r\\n            IV[2],\\r\\n            IV[3],\\r\\n            uint32(counter),\\r\\n            uint32(counter >> 32),\\r\\n            ///////////////////////////////\\r\\n            uint32(block_len),\\r\\n            flags\\r\\n        ];\\r\\n\\r\\n\\r\\n        _round(state, block_words); // round 1\\r\\n        _permute(block_words);\\r\\n        _round(state, block_words); // round 2\\r\\n        _permute(block_words);\\r\\n        _round(state, block_words); // round 3\\r\\n        _permute(block_words);\\r\\n        _round(state, block_words); // round 4\\r\\n        _permute(block_words);\\r\\n        _round(state, block_words); // round 5\\r\\n        _permute(block_words);\\r\\n        _round(state, block_words); // round 6\\r\\n        _permute(block_words);\\r\\n        _round(state, block_words); // round 7\\r\\n\\r\\n        for (uint256 i = 0; i < 8; ++i) {\\r\\n            state[i] ^= state[i + 8];\\r\\n            state[i + 8] ^= chaining_value[i];\\r\\n        }\\r\\n\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    function _rotr(uint32 x, uint8 n) internal pure returns (uint32) {\\r\\n        bytes4 b = bytes4(x);\\r\\n        return uint32((b >> n) | (b << (32 - n)));\\r\\n    }\\r\\n\\r\\n    function _chaining_value(Output memory o) internal pure returns (uint32[8] memory) {\\r\\n        uint32[16] memory compression_output = _compress(\\r\\n            o.input_chaining_value,\\r\\n            o.block_words,\\r\\n            o.counter,\\r\\n            o.block_len,\\r\\n            o.flags\\r\\n        );\\r\\n\\r\\n        return _first_8_words(compression_output);\\r\\n    }\\r\\n\\r\\n    function _root_output_bytes(\\r\\n        Output memory self,\\r\\n        bytes memory out_slice\\r\\n    ) internal pure {\\r\\n        //uint32 output_block_counter = 0;\\r\\n        // Take 64-byte chunks at a time from out_slice\\r\\n        //for (uint32 i = 0; i < out_slice.length; i += 2 * OUT_LEN) {\\r\\n        uint32[16] memory words = _compress(\\r\\n            self.input_chaining_value,\\r\\n            self.block_words,\\r\\n            0,\\r\\n            //output_block_counter,\\r\\n            self.block_len,\\r\\n            self.flags | ROOT\\r\\n        );\\r\\n\\r\\n        // Load compressed words into out_slice (4 bytes at a time)\\r\\n        // The output length might not be a multiple of 4.\\r\\n        //for (uint32 j = 0; j < words.length && out_slice.length > j*4; j++) {\\r\\n        //for (uint32 j = 0; j < words.length; j++) {\\r\\n        for (uint32 j = 0; j < 8; j++) {\\r\\n            // Load word at j into out_slice as little endian\\r\\n            _load_uint32_to_le_bytes(words[j], out_slice, j*4);\\r\\n        }\\r\\n\\r\\n            //output_block_counter += 1;\\r\\n        //}\\r\\n    }\\r\\n\\r\\n    function _load_uint32_to_le_bytes(\\r\\n        uint32 n,\\r\\n        bytes memory buf,\\r\\n        uint32 offset\\r\\n    ) internal pure {\\r\\n        for (uint256 i = 0; i < 4; ++i) {\\r\\n            buf[offset+i] = bytes1(uint8(n / (2 ** (i*8))));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _uint32_to_le_bytes(uint32 n) internal pure returns (bytes4) {\\r\\n        bytes4 buf;\\r\\n        for (uint256 i = 0; i < 4; ++i) {\\r\\n            assembly {\\r\\n                let cc := add(buf, 0x20)\\r\\n                let buf_idx := add(cc, sub(3, i))\\r\\n                let n_idx := add(n, i)\\r\\n                mstore8(buf_idx, n_idx)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return buf;\\r\\n    }\\r\\n\\r\\n\\r\\n    function _le_bytes_get_uint32(bytes memory _bytes, uint256 _start) public pure returns (uint32) {\\r\\n        require(_bytes.length >= _start + 4, \\\"le_bytes_get_uint32_outOfBounds\\\");\\r\\n        uint32 tempUint;\\r\\n\\r\\n        for (uint256 i = 0; i < 4; ++i) {\\r\\n            //tempUint += uint32(uint8(_bytes[i]) * (2 ** (8*i)));\\r\\n            tempUint += uint32(bytes4(_bytes[3-i+_start]) >> (8 * i));\\r\\n        }\\r\\n        /*\\r\\n        assembly {\\r\\n            // TODO why is this 0x4 in the bytes library???\\r\\n            //tempUint := mload(add(add(_bytes, 0x4), _start))\\r\\n\\r\\n            // Load 32 bytes from array (u256)\\r\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\r\\n            // Keep just the first 4 bytes (u32)\\r\\n            //tempUint := xor(tempUint, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000)\\r\\n            tempUint := xor(tempUint, 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\r\\n        }\\r\\n        */\\r\\n\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function _words_from_little_endian_bytes8(\\r\\n        bytes memory data_bytes,\\r\\n        uint32[8] memory words\\r\\n    ) internal pure {\\r\\n        require(data_bytes.length <= 4*8,\\r\\n                \\\"Data bytes is too long to convert to 8 4-byte words\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < data_bytes.length/4; ++i) {\\r\\n            words[i] = _le_bytes_get_uint32(data_bytes, i*4);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _words_from_little_endian_bytes(\\r\\n        bytes memory data_bytes,\\r\\n        uint32[16] memory words\\r\\n    ) internal pure {\\r\\n        require(data_bytes.length <= 64 && data_bytes.length%4 == 0,\\r\\n                \\\"Data bytes is too long to convert to 16 4-byte words\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < data_bytes.length/4; ++i) {\\r\\n            words[i] = _le_bytes_get_uint32(data_bytes, i*4);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    // TODO I wish this didn't require a copy to convert array sizes\\r\\n    function _first_8_words(uint32[16] memory words) internal pure returns (uint32[8] memory) {\\r\\n        // TODO there must be a way to do this without copying\\r\\n        // How to take a slice of a memory array?\\r\\n        uint32[8] memory first_8;\\r\\n        for (uint256 i = 0; i < 8; ++i) {\\r\\n            first_8[i] = words[i];\\r\\n        }\\r\\n\\r\\n        return first_8;\\r\\n    }\\r\\n\\r\\n\\r\\n    //\\r\\n    // Chunk state functions\\r\\n    //\\r\\n\\r\\n    function _new_chunkstate(\\r\\n        uint32[8] memory key_words,\\r\\n        uint64 chunk_counter,\\r\\n        uint32 flags\\r\\n    ) internal pure returns (ChunkState memory) {\\r\\n        bytes memory block_bytes = new bytes(BLOCK_LEN);\\r\\n        return ChunkState({\\r\\n            chaining_value: key_words,\\r\\n            chunk_counter: chunk_counter,\\r\\n            block_bytes: block_bytes,\\r\\n            block_len: 0,\\r\\n            blocks_compressed: 0,\\r\\n            flags: flags\\r\\n        });\\r\\n    }\\r\\n\\r\\n    function _len(ChunkState memory chunk) internal pure returns (uint256) {\\r\\n        return BLOCK_LEN * chunk.blocks_compressed + chunk.block_len;\\r\\n    }\\r\\n\\r\\n    function _start_flag(ChunkState memory chunk) internal pure returns (uint32) {\\r\\n        if (chunk.blocks_compressed == 0) {\\r\\n            return CHUNK_START;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Returns a new input offset\\r\\n    function _update_chunkstate(\\r\\n        ChunkState memory chunk,\\r\\n        bytes memory input\\r\\n    ) internal pure {//returns (uint32) {\\r\\n        uint256 input_offset = 0;\\r\\n        while (input_offset < input.length) {\\r\\n            // If the block buffer is full, compress it and clear it. More\\r\\n            // input is coming, so this compression is not CHUNK_END.\\r\\n            if (chunk.block_len == BLOCK_LEN) {\\r\\n                uint32[16] memory block_words;\\r\\n                _words_from_little_endian_bytes(chunk.block_bytes, block_words);\\r\\n                chunk.chaining_value = _first_8_words(_compress(\\r\\n                    chunk.chaining_value,\\r\\n                    block_words,\\r\\n                    chunk.chunk_counter,\\r\\n                    BLOCK_LEN,\\r\\n                    chunk.flags | _start_flag(chunk)\\r\\n                ));\\r\\n                chunk.blocks_compressed += 1;\\r\\n                // TODO probably cheaper to zero-out byte array than to reallocate\\r\\n                chunk.block_bytes = new bytes(BLOCK_LEN);\\r\\n                chunk.block_len = 0;\\r\\n            }\\r\\n\\r\\n            // Take enough to fill a block [min(want, input.length)]\\r\\n            uint256 want = BLOCK_LEN - chunk.block_len;\\r\\n            uint256 take = _min(want, input.length - input_offset);\\r\\n\\r\\n            // Copy bytes from input to chunk block\\r\\n            //chunk.block_bytes[self.block_len as usize..][..take].copy_from_slice(&input[..take]);\\r\\n            for (uint256 i = 0; i < take; ++i) {\\r\\n                // TODO recheck this logic\\r\\n                chunk.block_bytes[i+chunk.block_len] = input[input_offset+i];\\r\\n            }\\r\\n            /*\\r\\n            bytes memory block_ref = chunk.block_bytes;\\r\\n            uint32 blen = chunk.block_len;\\r\\n            assembly {\\r\\n                let block_addr := add(add(block_ref, 0x20), blen)\\r\\n                let input_addr := add(add(input.offset, 0x20), input_offset)\\r\\n                memorycopy(block_addr, input_addr, take)\\r\\n            }\\r\\n            */\\r\\n\\r\\n            chunk.block_len += take;\\r\\n            input_offset += take;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _min(uint256 x, uint256 y) internal pure returns (uint256) {\\r\\n        if (x < y) {\\r\\n            return x;\\r\\n        } else {\\r\\n            return y;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _output(ChunkState memory chunk) internal pure returns (Output memory) {\\r\\n        uint32[16] memory block_words;\\r\\n        _words_from_little_endian_bytes(chunk.block_bytes, block_words);\\r\\n\\r\\n        return Output({\\r\\n            input_chaining_value: chunk.chaining_value,\\r\\n            block_words: block_words,\\r\\n            counter: chunk.chunk_counter,\\r\\n            block_len: chunk.block_len,\\r\\n            flags: chunk.flags | _start_flag(chunk) | CHUNK_END\\r\\n        });\\r\\n    }\\r\\n\\r\\n    //\\r\\n    // Parent functions\\r\\n    //\\r\\n\\r\\n    function _parent_output(\\r\\n        uint32[8] memory left_child_cv,\\r\\n        uint32[8] memory right_child_cv,\\r\\n        uint32[8] memory key_words,\\r\\n        uint32 flags\\r\\n    ) internal pure returns (Output memory) {\\r\\n        uint32[16] memory block_words;\\r\\n\\r\\n        for (uint256 i = 0; i < 8; ++i) {\\r\\n            block_words[i] = left_child_cv[i];\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 8; i < 16; ++i) {\\r\\n            block_words[i] = right_child_cv[i - 8];\\r\\n        }\\r\\n\\r\\n        return Output({\\r\\n            input_chaining_value: key_words,\\r\\n            block_words: block_words,\\r\\n            counter: 0,           // Always 0 for parent nodes.\\r\\n            block_len: BLOCK_LEN, // Always BLOCK_LEN (64) for parent nodes.\\r\\n            flags: PARENT | flags\\r\\n        });\\r\\n    }\\r\\n\\r\\n    function _parent_cv(\\r\\n        uint32[8] memory left_child_cv,\\r\\n        uint32[8] memory right_child_cv,\\r\\n        uint32[8] memory key_words,\\r\\n        uint32 flags\\r\\n    ) internal pure returns (uint32[8] memory) {\\r\\n        return _chaining_value(_parent_output(left_child_cv, right_child_cv, key_words, flags));\\r\\n    }\\r\\n\\r\\n\\r\\n    //\\r\\n    // Hasher functions\\r\\n    //\\r\\n\\r\\n    function _new_hasher_internal(\\r\\n        uint32[8] memory key_words, uint32 flags\\r\\n    ) internal pure returns (Hasher memory) {\\r\\n        uint32[8][54] memory cv_stack;\\r\\n        return Hasher({\\r\\n            chunk_state: _new_chunkstate(key_words, 0, flags),\\r\\n            key_words: key_words,\\r\\n            cv_stack: cv_stack,\\r\\n            cv_stack_len: 0,\\r\\n            flags: flags\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /// Construct a new `Hasher` for the regular hash function.\\r\\n    function new_hasher() public pure returns (Hasher memory) {\\r\\n        uint32[8] memory IV = _IV();\\r\\n        return _new_hasher_internal(IV, 0);\\r\\n    }\\r\\n\\r\\n    /// Construct a new `Hasher` for the keyed hash function.\\r\\n    function new_keyed(bytes memory key) public pure returns (Hasher memory) {\\r\\n        uint32[8] memory key_words;\\r\\n        bytes memory key_mem = key;\\r\\n        _words_from_little_endian_bytes8(key_mem, key_words);\\r\\n        return _new_hasher_internal(key_words, KEYED_HASH);\\r\\n    }\\r\\n\\r\\n    // Construct a new `Hasher` for the key derivation function. The context\\r\\n    // string should be hardcoded, globally unique, and application-specific\\r\\n    function new_derive_key(bytes memory context) public pure returns (Hasher memory) {\\r\\n        uint32[8] memory IV = _IV();\\r\\n        Hasher memory context_hasher = _new_hasher_internal(IV, DERIVE_KEY_CONTEXT);\\r\\n        update_hasher(context_hasher, context);\\r\\n\\r\\n        bytes memory context_key = new bytes(256);\\r\\n        _finalize_internal(context_hasher, context_key);\\r\\n\\r\\n        uint32[8] memory context_key_words;\\r\\n        _words_from_little_endian_bytes8(context_key, context_key_words);\\r\\n\\r\\n        return _new_hasher_internal(context_key_words, DERIVE_KEY_MATERIAL);\\r\\n    }\\r\\n\\r\\n    function _push_stack(Hasher memory self, uint32[8] memory cv) internal pure {\\r\\n        self.cv_stack[self.cv_stack_len] = cv;\\r\\n        self.cv_stack_len += 1;\\r\\n    }\\r\\n\\r\\n    function _pop_stack(Hasher memory self) internal pure returns (uint32[8] memory) {\\r\\n        self.cv_stack_len -= 1;\\r\\n        return self.cv_stack[self.cv_stack_len];\\r\\n    }\\r\\n\\r\\n    function _add_chunk_chaining_value(\\r\\n        Hasher memory self,\\r\\n        uint32[8] memory new_cv,\\r\\n        uint64 total_chunks\\r\\n    ) internal pure {\\r\\n        while (total_chunks & 1 == 0) {\\r\\n            new_cv = _parent_cv(_pop_stack(self), new_cv, self.key_words, self.flags);\\r\\n            total_chunks >>= 1;\\r\\n        }\\r\\n\\r\\n        _push_stack(self, new_cv);\\r\\n    }\\r\\n\\r\\n    function _slice(\\r\\n        bytes memory data,\\r\\n        uint256 start,\\r\\n        uint256 end\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        uint256 dataSliceLength = end - start;\\r\\n        bytes memory dataSlice = new bytes(dataSliceLength);\\r\\n\\r\\n        for (uint256 i = 0; i < dataSliceLength; ++i) {\\r\\n            dataSlice[i] = data[start + i];\\r\\n        }\\r\\n\\r\\n        return dataSlice;\\r\\n    }\\r\\n\\r\\n    // Add input to the hash state. This can be called any number of times.\\r\\n    function update_hasher(\\r\\n        Hasher memory self, bytes memory input\\r\\n    ) public pure returns (Hasher memory) {\\r\\n        uint256 input_offset = 0;\\r\\n\\r\\n        while (input_offset < input.length) {\\r\\n            // If the current chunk is complete, finalize it and reset the\\r\\n            // chunk state. More input is coming, so this chunk is not ROOT.\\r\\n                if (_len(self.chunk_state) == CHUNK_LEN) {\\r\\n                uint32[8] memory chunk_cv = _chaining_value(_output(self.chunk_state));\\r\\n                uint64 total_chunks = self.chunk_state.chunk_counter + 1;\\r\\n\\r\\n                _add_chunk_chaining_value(self, chunk_cv, total_chunks);\\r\\n\\r\\n                self.chunk_state = _new_chunkstate(self.key_words, total_chunks, self.flags);\\r\\n            }\\r\\n\\r\\n            // Compress input bytes into the current chunk state.\\r\\n            uint256 want = CHUNK_LEN - _len(self.chunk_state);\\r\\n            uint256 take = _min(want, uint32(input.length - input_offset));\\r\\n\\r\\n            // Update chunk state\\r\\n            bytes memory input_slice = _slice(input, input_offset, take + input_offset);\\r\\n            _update_chunkstate(self.chunk_state, input_slice);\\r\\n\\r\\n            input_offset += take;\\r\\n        }\\r\\n\\r\\n        return self;\\r\\n    }\\r\\n\\r\\n    function finalize(Hasher memory self) public pure returns (bytes memory) {\\r\\n        bytes memory output = new bytes(32);\\r\\n\\r\\n        _finalize_internal(self, output);\\r\\n\\r\\n        return output;\\r\\n    }\\r\\n\\r\\n    function _finalize_internal(\\r\\n        Hasher memory self, bytes memory out_slice\\r\\n    ) internal pure {\\r\\n        // Starting with the Output from the current chunk, compute all the\\r\\n        // parent chaining values along the right edge of the tree, until we\\r\\n        // have the root Output.\\r\\n        Output memory output = _output(self.chunk_state);\\r\\n        uint32 parent_nodes_remaining = self.cv_stack_len;\\r\\n\\r\\n        while (parent_nodes_remaining > 0) {\\r\\n            parent_nodes_remaining -= 1;\\r\\n\\r\\n            output = _parent_output(\\r\\n                self.cv_stack[parent_nodes_remaining],\\r\\n                _chaining_value(output),\\r\\n                self.key_words,\\r\\n                self.flags\\r\\n            );\\r\\n        }\\r\\n        _root_output_bytes(output, out_slice);\\r\\n    }\\r\\n}\",\"keccak256\":\"0x633ec836347082c2f9d4611ea9ea99d75979a72327ea1998db13366e46de97c4\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612228806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a35760003560e01c8063b787e79411610076578063c51d2cd71161005b578063c51d2cd71461011c578063dcf319ff1461012f578063fd5fc0861461015757600080fd5b8063b787e79414610101578063c03e02271461011457600080fd5b80630d056d9b146100a857806312a63b5d146100c6578063715bdd54146100d9578063b2032f74146100ee575b600080fd5b6100b061015f565b6040516100bd9190611a3e565b60405180910390f35b6100b06100d4366004611bf6565b610184565b6100e1610207565b6040516100bd9190611c2b565b6100b06100fc366004611e72565b61027a565b6100e161010f366004611ed6565b610378565b6100e16103a7565b6100b061012a366004611bf6565b610438565b61014261013d366004611f0b565b610466565b60405163ffffffff90911681526020016100bd565b6100e1610559565b610167611865565b6000610171610565565b905061017e8160006105cb565b91505090565b61018c611865565b6000610196610565565b905060006101a58260206105cb565b90506101b1818561027a565b506040805161010080825261012082019092526000916020820181803683370190505090506101e08282610620565b6101e86118a6565b6101f282826106a7565b6101fd8160406105cb565b9695505050505050565b606060006102376040518060400160405280600b81526020016a68656c6c6f68656c6c6f2160a81b815250610438565b9050610266816040518060400160405280600b81526020016a68656c6c6f68656c6c6f3f60a81b81525061027a565b9050600061027382610378565b9392505050565b610282611865565b60005b825181101561036d5783516104009061029d9061077d565b14156102f65760006102ba6102b5866000015161079f565b610819565b8551602001519091506000906102d1906001611f66565b90506102de86838361084f565b6102f18660200151828860800151610891565b865250505b6000610305856000015161077d565b61031190610400611f92565b90506000610331828487516103269190611f92565b63ffffffff166108f9565b9050600061034986856103448186611fa9565b610911565b90506103598760000151826109dd565b6103638285611fa9565b9350505050610285565b839150505b92915050565b604080516020808252818301909252606091600091906020820181803683370190505090506103728382610620565b606060006103d76040518060400160405280600b81526020016a68656c6c6f68656c6c6f2160a81b815250610438565b9050606060005b600a81101561043157610414836040518060400160405280600b81526020016a68656c6c6f68656c6c6f3f60a81b81525061027a565b925061041f83610378565b915061042a81611fc1565b90506103de565b5092915050565b610440611865565b6104486118a6565b8261045381836106a7565b61045e8260106105cb565b949350505050565b6000610473826004611fa9565b835110156104c85760405162461bcd60e51b815260206004820152601f60248201527f6c655f62797465735f6765745f75696e7433325f6f75744f66426f756e64730060448201526064015b60405180910390fd5b6000805b6004811015610551576104e0816008611fdc565b85856104ed846003611f92565b6104f79190611fa9565b8151811061050757610507611ffb565b016020015161053f917fff00000000000000000000000000000000000000000000000000000000000000909116901c60e01c83612011565b915061054a81611fc1565b90506104cc565b509392505050565b6060600061023761015f565b61056d6118a6565b506040805161010081018252636a09e667815263bb67ae856020820152633c6ef3729181019190915263a54ff53a606082015263510e527f6080820152639b05688c60a0820152631f83d9ab60c0820152635be0cd1960e082015290565b6105d3611865565b6105db6118c5565b6040518060a001604052806105f286600087610891565b8152602001858152602001828152602001600060ff1681526020018463ffffffff1681525091505092915050565b600061062f836000015161079f565b606084015190915060ff165b63ffffffff81161561069757610652600182612030565b905061069084604001518263ffffffff166036811061067357610673611ffb565b602002015161068184610819565b86602001518760800151610b4f565b915061063b565b6106a18284610c4a565b50505050565b60208251111561071f5760405162461bcd60e51b815260206004820152603360248201527f4461746120627974657320697320746f6f206c6f6e6720746f20636f6e76657260448201527f7420746f203820342d6279746520776f7264730000000000000000000000000060648201526084016104bf565b60005b60048351610730919061206b565b811015610778576107468361013d836004611fdc565b82826008811061075857610758611ffb565b63ffffffff909216602092909202015261077181611fc1565b9050610722565b505050565b60008160600151826080015160406107959190611fdc565b6103729190611fa9565b6107a76118f3565b6107af61192e565b6107bd836040015182610cc4565b6040518060a0016040528084600001518152602001828152602001846020015167ffffffffffffffff16815260200184606001518152602001600261080186610dac565b8660a00151171763ffffffff16815250915050919050565b6108216118a6565b600061084483600001518460200151856040015186606001518760800151610dd0565b9050610273816110bc565b600181166108875761087361086384611121565b838560200151866080015161116d565b915060011c677fffffffffffffff1661084f565b610778838361118d565b61089961194d565b60408051818152606081018252600091602082018180368337019050506040805160c08101825296875267ffffffffffffffff90951660208701529385019390935250600060608401819052608084015263ffffffff1660a08301525090565b60008183101561090a575081610372565b5080610372565b6060600061091f8484611f92565b905060008167ffffffffffffffff81111561093c5761093c611b07565b6040519080825280601f01601f191660200182016040528015610966576020820181803683370190505b50905060005b828110156109d3578661097f8288611fa9565b8151811061098f5761098f611ffb565b602001015160f81c60f81b8282815181106109ac576109ac611ffb565b60200101906001600160f81b031916908160001a9053506109cc81611fc1565b905061096c565b5095945050505050565b60005b815181101561077857604083606001511415610a7a576109fe61192e565b610a0c846040015182610cc4565b610a38610a3385600001518387602001516040610a288a610dac565b8a60a0015117610dd0565b6110bc565b845260808401805160019190610a4f908390611fa9565b9052506040805181815260608101825290602082018180368337505050604085015250600060608401525b600083606001516040610a8d9190611f92565b90506000610aa782848651610aa29190611f92565b6108f9565b905060005b81811015610b265784610abf8286611fa9565b81518110610acf57610acf611ffb565b602001015160f81c60f81b8660400151876060015183610aef9190611fa9565b81518110610aff57610aff611ffb565b60200101906001600160f81b031916908160001a905350610b1f81611fc1565b9050610aac565b508085606001818151610b399190611fa9565b905250610b468184611fa9565b925050506109e0565b610b576118f3565b610b5f61192e565b60005b6008811015610bb457868160088110610b7d57610b7d611ffb565b6020020151828260108110610b9457610b94611ffb565b63ffffffff9092166020929092020152610bad81611fc1565b9050610b62565b5060085b6010811015610c145785610bcd600883611f92565b60088110610bdd57610bdd611ffb565b6020020151828260108110610bf457610bf4611ffb565b63ffffffff9092166020929092020152610c0d81611fc1565b9050610bb8565b506040805160a081018252948552602085019190915260008482015260608401525060041763ffffffff16608082015292915050565b6000610c6d83600001518460200151600086606001516008886080015117610dd0565b905060005b60088163ffffffff1610156106a157610cb2828263ffffffff1660108110610c9c57610c9c611ffb565b602002015184610cad84600461207f565b6111cf565b80610cbc816120ab565b915050610c72565b6040825111158015610ce1575060048251610cdf91906120cf565b155b610d535760405162461bcd60e51b815260206004820152603460248201527f4461746120627974657320697320746f6f206c6f6e6720746f20636f6e76657260448201527f7420746f20313620342d6279746520776f72647300000000000000000000000060648201526084016104bf565b60005b60048351610d64919061206b565b81101561077857610d7a8361013d836004611fdc565b828260108110610d8c57610d8c611ffb565b63ffffffff9092166020929092020152610da581611fc1565b9050610d56565b6000816080015160001415610dc357506001919050565b506000919050565b919050565b610dd861192e565b6000610de2610565565b9050610dec61192e565b60005b6010811015610e4157878160108110610e0a57610e0a611ffb565b6020020151828260108110610e2157610e21611ffb565b63ffffffff9092166020929092020152610e3a81611fc1565b9050610def565b5060006040518061020001604052808a600060088110610e6357610e63611ffb565b6020908102919091015163ffffffff168252018a60016020908102919091015163ffffffff168252018a60026020908102919091015163ffffffff168252018a60036020908102919091015163ffffffff168252018a60046020908102919091015163ffffffff168252018a60056020908102919091015163ffffffff168252018a60066020908102919091015163ffffffff168252018a60076020908102919091015163ffffffff168252018460006020908102919091015163ffffffff168252018460016020908102919091015163ffffffff168252018460026020908102919091015163ffffffff168252018460036020908102919091015163ffffffff90811683528a811683830152908a901c81166040830152888116606083015287166080909101529050610f97818361124c565b610fa082611334565b610faa818361124c565b610fb382611334565b610fbd818361124c565b610fc682611334565b610fd0818361124c565b610fd982611334565b610fe3818361124c565b610fec82611334565b610ff6818361124c565b610fff82611334565b611009818361124c565b60005b60088110156110af5781611021826008611fa9565b6010811061103157611031611ffb565b602002015182826010811061104857611048611ffb565b6020020180519190911863ffffffff16905289816008811061106c5761106c611ffb565b60200201518261107d836008611fa9565b6010811061108d5761108d611ffb565b6020020180519190911863ffffffff1690526110a881611fc1565b905061100c565b5098975050505050505050565b6110c46118a6565b6110cc6118a6565b60005b6008811015610431578381601081106110ea576110ea611ffb565b602002015182826008811061110157611101611ffb565b63ffffffff909216602092909202015261111a81611fc1565b90506110cf565b6111296118a6565b60018260600181815161113c91906120e3565b60ff90811690915260408401516060850151909250166036811061116257611162611ffb565b602002015192915050565b6111756118a6565b6111846102b586868686610b4f565b95945050505050565b808260400151836060015160ff16603681106111ab576111ab611ffb565b6020020152606082018051600191906111c5908390612106565b60ff169052505050565b60005b60048110156106a1576111e6816008611fdc565b6111f190600261220f565b6112019063ffffffff861661206b565b60f81b836112158363ffffffff8616611fa9565b8151811061122557611225611ffb565b60200101906001600160f81b031916908160001a90535061124581611fc1565b90506111d2565b61126d82600060046008600c868460200201518760015b602002015161140c565b61128982600160056009600d8660026020020151876003611263565b6112a58260026006600a600e8660046020020151876005611263565b6112c18260036007600b600f8660066020020151876007611263565b6112dd8260006005600a600f8660086020020151876009611263565b6112f98260016006600b600c86600a602002015187600b611263565b61131582600260076008600d86600c602002015187600d611263565b61133082600360046009600e8681602002015187600f611263565b5050565b600061133e61178a565b905061134861192e565b60005b60108110156113b6578383826010811061136757611367611ffb565b602002015160ff166010811061137f5761137f611ffb565b602002015182826010811061139657611396611ffb565b63ffffffff90921660209290920201526113af81611fc1565b905061134b565b5060005b60108110156106a1578181601081106113d5576113d5611ffb565b60200201518482601081106113ec576113ec611ffb565b63ffffffff909216602092909202015261140581611fc1565b90506113ba565b81878663ffffffff166010811061142557611425611ffb565b6020020151888863ffffffff166010811061144257611442611ffb565b60200201510101878763ffffffff166010811061146157611461611ffb565b602002019063ffffffff16908163ffffffff16815250506114bd878763ffffffff166010811061149357611493611ffb565b6020020151888563ffffffff16601081106114b0576114b0611ffb565b6020020151186010611818565b878463ffffffff16601081106114d5576114d5611ffb565b602002019063ffffffff16908163ffffffff1681525050868363ffffffff166010811061150457611504611ffb565b6020020151878563ffffffff166010811061152157611521611ffb565b602002015101878563ffffffff166010811061153f5761153f611ffb565b602002019063ffffffff16908163ffffffff168152505061159b878563ffffffff166010811061157157611571611ffb565b6020020151888763ffffffff166010811061158e5761158e611ffb565b602002015118600c611818565b878663ffffffff16601081106115b3576115b3611ffb565b602002019063ffffffff16908163ffffffff168152505080878663ffffffff16601081106115e3576115e3611ffb565b6020020151888863ffffffff166010811061160057611600611ffb565b60200201510101878763ffffffff166010811061161f5761161f611ffb565b602002019063ffffffff16908163ffffffff168152505061167b878763ffffffff166010811061165157611651611ffb565b6020020151888563ffffffff166010811061166e5761166e611ffb565b6020020151186008611818565b878463ffffffff166010811061169357611693611ffb565b602002019063ffffffff16908163ffffffff1681525050868363ffffffff16601081106116c2576116c2611ffb565b6020020151878563ffffffff16601081106116df576116df611ffb565b602002015101878563ffffffff16601081106116fd576116fd611ffb565b602002019063ffffffff16908163ffffffff1681525050611759878563ffffffff166010811061172f5761172f611ffb565b6020020151888763ffffffff166010811061174c5761174c611ffb565b6020020151186007611818565b878663ffffffff166010811061177157611771611ffb565b63ffffffff909216602092909202015250505050505050565b61179261192e565b5060408051610200810182526002815260066020820152600391810191909152600a606082015260076080820152600060a0820152600460c0820152600d60e08201526001610100820152600b610120820152600c61014082015260056101608201526009610180820152600e6101a0820152600f6101c082015260086101e082015290565b600060e083901b61182a8360206120e3565b7fffffffff0000000000000000000000000000000000000000000000000000000090911660ff84811682901c92161b1760e01c905092915050565b6040518060a0016040528061187861194d565b81526020016118856118a6565b81526020016118926118c5565b815260006020820181905260409091015290565b6040518061010001604052806008906020820280368337509192915050565b604051806106c001604052806036905b6118dd6118a6565b8152602001906001900390816118d55790505090565b6040518060a001604052806119066118a6565b815260200161191361192e565b81526000602082018190526040820181905260609091015290565b6040518061020001604052806010906020820280368337509192915050565b6040518060c001604052806119606118a6565b8152602001600067ffffffffffffffff168152602001606081526020016000815260200160008152602001600063ffffffff1681525090565b8060005b60088110156106a157815163ffffffff1684526020938401939091019060010161199d565b6000815180845260005b818110156119e8576020818501810151868301820152016119cc565b818111156119fa576000602083870101525b50601f01601f19169290920160200192915050565b8060005b60368110156106a157611a27848351611999565b610100939093019260209190910190600101611a13565b6020815260008251613760806020850152611a5e61378085018351611999565b67ffffffffffffffff60208301511661388085015260408201516101a06138a0860152611a8f6139208601826119c2565b60608401516138c087015260808401516138e087015260a09093015163ffffffff1661390086015250602085015191611acb6040860184611999565b60408601519250611ae0610140860184611a0f565b606086015160ff1661374086015260809095015163ffffffff169301929092525090919050565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715611b4057611b40611b07565b60405290565b60405160c0810167ffffffffffffffff81118282101715611b4057611b40611b07565b600082601f830112611b7a57600080fd5b813567ffffffffffffffff80821115611b9557611b95611b07565b604051601f8301601f19908116603f01168101908282118183101715611bbd57611bbd611b07565b81604052838152866020858801011115611bd657600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060208284031215611c0857600080fd5b813567ffffffffffffffff811115611c1f57600080fd5b61045e84828501611b69565b60208152600061027360208301846119c2565b803563ffffffff81168114610dcb57600080fd5b600082601f830112611c6357600080fd5b60405161010080820182811067ffffffffffffffff82111715611c8857611c88611b07565b60405283018185821115611c9b57600080fd5b845b82811015611cbc57611cae81611c3e565b825260209182019101611c9d565b509195945050505050565b803567ffffffffffffffff81168114610dcb57600080fd5b600082601f830112611cf057600080fd5b6040516106c0810181811067ffffffffffffffff82111715611d1457611d14611b07565b60405280613600840185811115611d2a57600080fd5b845b81811015611cbc57611d3e8782611c52565b835260209092019161010001611d2c565b803560ff81168114610dcb57600080fd5b60006137608284031215611d7357600080fd5b611d7b611b1d565b9050813567ffffffffffffffff80821115611d9557600080fd5b908301906101a08286031215611daa57600080fd5b611db2611b46565b611dbc8684611c52565b8152611dcb6101008401611cc7565b60208201526101208084013583811115611de457600080fd5b611df088828701611b69565b60408401525061014084013560608301526101608401356080830152611e196101808501611c3e565b60a0830152818552611e2e8760208801611c52565b6020860152611e3f87828801611cdf565b604086015250505050611e556137208301611d4f565b6060820152611e676137408301611c3e565b608082015292915050565b60008060408385031215611e8557600080fd5b823567ffffffffffffffff80821115611e9d57600080fd5b611ea986838701611d60565b93506020850135915080821115611ebf57600080fd5b50611ecc85828601611b69565b9150509250929050565b600060208284031215611ee857600080fd5b813567ffffffffffffffff811115611eff57600080fd5b61045e84828501611d60565b60008060408385031215611f1e57600080fd5b823567ffffffffffffffff811115611f3557600080fd5b611f4185828601611b69565b95602094909401359450505050565b634e487b7160e01b600052601160045260246000fd5b600067ffffffffffffffff808316818516808303821115611f8957611f89611f50565b01949350505050565b600082821015611fa457611fa4611f50565b500390565b60008219821115611fbc57611fbc611f50565b500190565b6000600019821415611fd557611fd5611f50565b5060010190565b6000816000190483118215151615611ff657611ff6611f50565b500290565b634e487b7160e01b600052603260045260246000fd5b600063ffffffff808316818516808303821115611f8957611f89611f50565b600063ffffffff8381169083168181101561204d5761204d611f50565b039392505050565b634e487b7160e01b600052601260045260246000fd5b60008261207a5761207a612055565b500490565b600063ffffffff808316818516818304811182151516156120a2576120a2611f50565b02949350505050565b600063ffffffff808316818114156120c5576120c5611f50565b6001019392505050565b6000826120de576120de612055565b500690565b600060ff821660ff8416808210156120fd576120fd611f50565b90039392505050565b600060ff821660ff84168060ff0382111561212357612123611f50565b019392505050565b600181815b8085111561216657816000190482111561214c5761214c611f50565b8085161561215957918102915b93841c9390800290612130565b509250929050565b60008261217d57506001610372565b8161218a57506000610372565b81600181146121a057600281146121aa576121c6565b6001915050610372565b60ff8411156121bb576121bb611f50565b50506001821b610372565b5060208310610133831016604e8410600b84101617156121e9575081810a610372565b6121f3838361212b565b806000190482111561220757612207611f50565b029392505050565b6000610273838361216e56fea164736f6c6343000809000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a35760003560e01c8063b787e79411610076578063c51d2cd71161005b578063c51d2cd71461011c578063dcf319ff1461012f578063fd5fc0861461015757600080fd5b8063b787e79414610101578063c03e02271461011457600080fd5b80630d056d9b146100a857806312a63b5d146100c6578063715bdd54146100d9578063b2032f74146100ee575b600080fd5b6100b061015f565b6040516100bd9190611a3e565b60405180910390f35b6100b06100d4366004611bf6565b610184565b6100e1610207565b6040516100bd9190611c2b565b6100b06100fc366004611e72565b61027a565b6100e161010f366004611ed6565b610378565b6100e16103a7565b6100b061012a366004611bf6565b610438565b61014261013d366004611f0b565b610466565b60405163ffffffff90911681526020016100bd565b6100e1610559565b610167611865565b6000610171610565565b905061017e8160006105cb565b91505090565b61018c611865565b6000610196610565565b905060006101a58260206105cb565b90506101b1818561027a565b506040805161010080825261012082019092526000916020820181803683370190505090506101e08282610620565b6101e86118a6565b6101f282826106a7565b6101fd8160406105cb565b9695505050505050565b606060006102376040518060400160405280600b81526020016a68656c6c6f68656c6c6f2160a81b815250610438565b9050610266816040518060400160405280600b81526020016a68656c6c6f68656c6c6f3f60a81b81525061027a565b9050600061027382610378565b9392505050565b610282611865565b60005b825181101561036d5783516104009061029d9061077d565b14156102f65760006102ba6102b5866000015161079f565b610819565b8551602001519091506000906102d1906001611f66565b90506102de86838361084f565b6102f18660200151828860800151610891565b865250505b6000610305856000015161077d565b61031190610400611f92565b90506000610331828487516103269190611f92565b63ffffffff166108f9565b9050600061034986856103448186611fa9565b610911565b90506103598760000151826109dd565b6103638285611fa9565b9350505050610285565b839150505b92915050565b604080516020808252818301909252606091600091906020820181803683370190505090506103728382610620565b606060006103d76040518060400160405280600b81526020016a68656c6c6f68656c6c6f2160a81b815250610438565b9050606060005b600a81101561043157610414836040518060400160405280600b81526020016a68656c6c6f68656c6c6f3f60a81b81525061027a565b925061041f83610378565b915061042a81611fc1565b90506103de565b5092915050565b610440611865565b6104486118a6565b8261045381836106a7565b61045e8260106105cb565b949350505050565b6000610473826004611fa9565b835110156104c85760405162461bcd60e51b815260206004820152601f60248201527f6c655f62797465735f6765745f75696e7433325f6f75744f66426f756e64730060448201526064015b60405180910390fd5b6000805b6004811015610551576104e0816008611fdc565b85856104ed846003611f92565b6104f79190611fa9565b8151811061050757610507611ffb565b016020015161053f917fff00000000000000000000000000000000000000000000000000000000000000909116901c60e01c83612011565b915061054a81611fc1565b90506104cc565b509392505050565b6060600061023761015f565b61056d6118a6565b506040805161010081018252636a09e667815263bb67ae856020820152633c6ef3729181019190915263a54ff53a606082015263510e527f6080820152639b05688c60a0820152631f83d9ab60c0820152635be0cd1960e082015290565b6105d3611865565b6105db6118c5565b6040518060a001604052806105f286600087610891565b8152602001858152602001828152602001600060ff1681526020018463ffffffff1681525091505092915050565b600061062f836000015161079f565b606084015190915060ff165b63ffffffff81161561069757610652600182612030565b905061069084604001518263ffffffff166036811061067357610673611ffb565b602002015161068184610819565b86602001518760800151610b4f565b915061063b565b6106a18284610c4a565b50505050565b60208251111561071f5760405162461bcd60e51b815260206004820152603360248201527f4461746120627974657320697320746f6f206c6f6e6720746f20636f6e76657260448201527f7420746f203820342d6279746520776f7264730000000000000000000000000060648201526084016104bf565b60005b60048351610730919061206b565b811015610778576107468361013d836004611fdc565b82826008811061075857610758611ffb565b63ffffffff909216602092909202015261077181611fc1565b9050610722565b505050565b60008160600151826080015160406107959190611fdc565b6103729190611fa9565b6107a76118f3565b6107af61192e565b6107bd836040015182610cc4565b6040518060a0016040528084600001518152602001828152602001846020015167ffffffffffffffff16815260200184606001518152602001600261080186610dac565b8660a00151171763ffffffff16815250915050919050565b6108216118a6565b600061084483600001518460200151856040015186606001518760800151610dd0565b9050610273816110bc565b600181166108875761087361086384611121565b838560200151866080015161116d565b915060011c677fffffffffffffff1661084f565b610778838361118d565b61089961194d565b60408051818152606081018252600091602082018180368337019050506040805160c08101825296875267ffffffffffffffff90951660208701529385019390935250600060608401819052608084015263ffffffff1660a08301525090565b60008183101561090a575081610372565b5080610372565b6060600061091f8484611f92565b905060008167ffffffffffffffff81111561093c5761093c611b07565b6040519080825280601f01601f191660200182016040528015610966576020820181803683370190505b50905060005b828110156109d3578661097f8288611fa9565b8151811061098f5761098f611ffb565b602001015160f81c60f81b8282815181106109ac576109ac611ffb565b60200101906001600160f81b031916908160001a9053506109cc81611fc1565b905061096c565b5095945050505050565b60005b815181101561077857604083606001511415610a7a576109fe61192e565b610a0c846040015182610cc4565b610a38610a3385600001518387602001516040610a288a610dac565b8a60a0015117610dd0565b6110bc565b845260808401805160019190610a4f908390611fa9565b9052506040805181815260608101825290602082018180368337505050604085015250600060608401525b600083606001516040610a8d9190611f92565b90506000610aa782848651610aa29190611f92565b6108f9565b905060005b81811015610b265784610abf8286611fa9565b81518110610acf57610acf611ffb565b602001015160f81c60f81b8660400151876060015183610aef9190611fa9565b81518110610aff57610aff611ffb565b60200101906001600160f81b031916908160001a905350610b1f81611fc1565b9050610aac565b508085606001818151610b399190611fa9565b905250610b468184611fa9565b925050506109e0565b610b576118f3565b610b5f61192e565b60005b6008811015610bb457868160088110610b7d57610b7d611ffb565b6020020151828260108110610b9457610b94611ffb565b63ffffffff9092166020929092020152610bad81611fc1565b9050610b62565b5060085b6010811015610c145785610bcd600883611f92565b60088110610bdd57610bdd611ffb565b6020020151828260108110610bf457610bf4611ffb565b63ffffffff9092166020929092020152610c0d81611fc1565b9050610bb8565b506040805160a081018252948552602085019190915260008482015260608401525060041763ffffffff16608082015292915050565b6000610c6d83600001518460200151600086606001516008886080015117610dd0565b905060005b60088163ffffffff1610156106a157610cb2828263ffffffff1660108110610c9c57610c9c611ffb565b602002015184610cad84600461207f565b6111cf565b80610cbc816120ab565b915050610c72565b6040825111158015610ce1575060048251610cdf91906120cf565b155b610d535760405162461bcd60e51b815260206004820152603460248201527f4461746120627974657320697320746f6f206c6f6e6720746f20636f6e76657260448201527f7420746f20313620342d6279746520776f72647300000000000000000000000060648201526084016104bf565b60005b60048351610d64919061206b565b81101561077857610d7a8361013d836004611fdc565b828260108110610d8c57610d8c611ffb565b63ffffffff9092166020929092020152610da581611fc1565b9050610d56565b6000816080015160001415610dc357506001919050565b506000919050565b919050565b610dd861192e565b6000610de2610565565b9050610dec61192e565b60005b6010811015610e4157878160108110610e0a57610e0a611ffb565b6020020151828260108110610e2157610e21611ffb565b63ffffffff9092166020929092020152610e3a81611fc1565b9050610def565b5060006040518061020001604052808a600060088110610e6357610e63611ffb565b6020908102919091015163ffffffff168252018a60016020908102919091015163ffffffff168252018a60026020908102919091015163ffffffff168252018a60036020908102919091015163ffffffff168252018a60046020908102919091015163ffffffff168252018a60056020908102919091015163ffffffff168252018a60066020908102919091015163ffffffff168252018a60076020908102919091015163ffffffff168252018460006020908102919091015163ffffffff168252018460016020908102919091015163ffffffff168252018460026020908102919091015163ffffffff168252018460036020908102919091015163ffffffff90811683528a811683830152908a901c81166040830152888116606083015287166080909101529050610f97818361124c565b610fa082611334565b610faa818361124c565b610fb382611334565b610fbd818361124c565b610fc682611334565b610fd0818361124c565b610fd982611334565b610fe3818361124c565b610fec82611334565b610ff6818361124c565b610fff82611334565b611009818361124c565b60005b60088110156110af5781611021826008611fa9565b6010811061103157611031611ffb565b602002015182826010811061104857611048611ffb565b6020020180519190911863ffffffff16905289816008811061106c5761106c611ffb565b60200201518261107d836008611fa9565b6010811061108d5761108d611ffb565b6020020180519190911863ffffffff1690526110a881611fc1565b905061100c565b5098975050505050505050565b6110c46118a6565b6110cc6118a6565b60005b6008811015610431578381601081106110ea576110ea611ffb565b602002015182826008811061110157611101611ffb565b63ffffffff909216602092909202015261111a81611fc1565b90506110cf565b6111296118a6565b60018260600181815161113c91906120e3565b60ff90811690915260408401516060850151909250166036811061116257611162611ffb565b602002015192915050565b6111756118a6565b6111846102b586868686610b4f565b95945050505050565b808260400151836060015160ff16603681106111ab576111ab611ffb565b6020020152606082018051600191906111c5908390612106565b60ff169052505050565b60005b60048110156106a1576111e6816008611fdc565b6111f190600261220f565b6112019063ffffffff861661206b565b60f81b836112158363ffffffff8616611fa9565b8151811061122557611225611ffb565b60200101906001600160f81b031916908160001a90535061124581611fc1565b90506111d2565b61126d82600060046008600c868460200201518760015b602002015161140c565b61128982600160056009600d8660026020020151876003611263565b6112a58260026006600a600e8660046020020151876005611263565b6112c18260036007600b600f8660066020020151876007611263565b6112dd8260006005600a600f8660086020020151876009611263565b6112f98260016006600b600c86600a602002015187600b611263565b61131582600260076008600d86600c602002015187600d611263565b61133082600360046009600e8681602002015187600f611263565b5050565b600061133e61178a565b905061134861192e565b60005b60108110156113b6578383826010811061136757611367611ffb565b602002015160ff166010811061137f5761137f611ffb565b602002015182826010811061139657611396611ffb565b63ffffffff90921660209290920201526113af81611fc1565b905061134b565b5060005b60108110156106a1578181601081106113d5576113d5611ffb565b60200201518482601081106113ec576113ec611ffb565b63ffffffff909216602092909202015261140581611fc1565b90506113ba565b81878663ffffffff166010811061142557611425611ffb565b6020020151888863ffffffff166010811061144257611442611ffb565b60200201510101878763ffffffff166010811061146157611461611ffb565b602002019063ffffffff16908163ffffffff16815250506114bd878763ffffffff166010811061149357611493611ffb565b6020020151888563ffffffff16601081106114b0576114b0611ffb565b6020020151186010611818565b878463ffffffff16601081106114d5576114d5611ffb565b602002019063ffffffff16908163ffffffff1681525050868363ffffffff166010811061150457611504611ffb565b6020020151878563ffffffff166010811061152157611521611ffb565b602002015101878563ffffffff166010811061153f5761153f611ffb565b602002019063ffffffff16908163ffffffff168152505061159b878563ffffffff166010811061157157611571611ffb565b6020020151888763ffffffff166010811061158e5761158e611ffb565b602002015118600c611818565b878663ffffffff16601081106115b3576115b3611ffb565b602002019063ffffffff16908163ffffffff168152505080878663ffffffff16601081106115e3576115e3611ffb565b6020020151888863ffffffff166010811061160057611600611ffb565b60200201510101878763ffffffff166010811061161f5761161f611ffb565b602002019063ffffffff16908163ffffffff168152505061167b878763ffffffff166010811061165157611651611ffb565b6020020151888563ffffffff166010811061166e5761166e611ffb565b6020020151186008611818565b878463ffffffff166010811061169357611693611ffb565b602002019063ffffffff16908163ffffffff1681525050868363ffffffff16601081106116c2576116c2611ffb565b6020020151878563ffffffff16601081106116df576116df611ffb565b602002015101878563ffffffff16601081106116fd576116fd611ffb565b602002019063ffffffff16908163ffffffff1681525050611759878563ffffffff166010811061172f5761172f611ffb565b6020020151888763ffffffff166010811061174c5761174c611ffb565b6020020151186007611818565b878663ffffffff166010811061177157611771611ffb565b63ffffffff909216602092909202015250505050505050565b61179261192e565b5060408051610200810182526002815260066020820152600391810191909152600a606082015260076080820152600060a0820152600460c0820152600d60e08201526001610100820152600b610120820152600c61014082015260056101608201526009610180820152600e6101a0820152600f6101c082015260086101e082015290565b600060e083901b61182a8360206120e3565b7fffffffff0000000000000000000000000000000000000000000000000000000090911660ff84811682901c92161b1760e01c905092915050565b6040518060a0016040528061187861194d565b81526020016118856118a6565b81526020016118926118c5565b815260006020820181905260409091015290565b6040518061010001604052806008906020820280368337509192915050565b604051806106c001604052806036905b6118dd6118a6565b8152602001906001900390816118d55790505090565b6040518060a001604052806119066118a6565b815260200161191361192e565b81526000602082018190526040820181905260609091015290565b6040518061020001604052806010906020820280368337509192915050565b6040518060c001604052806119606118a6565b8152602001600067ffffffffffffffff168152602001606081526020016000815260200160008152602001600063ffffffff1681525090565b8060005b60088110156106a157815163ffffffff1684526020938401939091019060010161199d565b6000815180845260005b818110156119e8576020818501810151868301820152016119cc565b818111156119fa576000602083870101525b50601f01601f19169290920160200192915050565b8060005b60368110156106a157611a27848351611999565b610100939093019260209190910190600101611a13565b6020815260008251613760806020850152611a5e61378085018351611999565b67ffffffffffffffff60208301511661388085015260408201516101a06138a0860152611a8f6139208601826119c2565b60608401516138c087015260808401516138e087015260a09093015163ffffffff1661390086015250602085015191611acb6040860184611999565b60408601519250611ae0610140860184611a0f565b606086015160ff1661374086015260809095015163ffffffff169301929092525090919050565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715611b4057611b40611b07565b60405290565b60405160c0810167ffffffffffffffff81118282101715611b4057611b40611b07565b600082601f830112611b7a57600080fd5b813567ffffffffffffffff80821115611b9557611b95611b07565b604051601f8301601f19908116603f01168101908282118183101715611bbd57611bbd611b07565b81604052838152866020858801011115611bd657600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060208284031215611c0857600080fd5b813567ffffffffffffffff811115611c1f57600080fd5b61045e84828501611b69565b60208152600061027360208301846119c2565b803563ffffffff81168114610dcb57600080fd5b600082601f830112611c6357600080fd5b60405161010080820182811067ffffffffffffffff82111715611c8857611c88611b07565b60405283018185821115611c9b57600080fd5b845b82811015611cbc57611cae81611c3e565b825260209182019101611c9d565b509195945050505050565b803567ffffffffffffffff81168114610dcb57600080fd5b600082601f830112611cf057600080fd5b6040516106c0810181811067ffffffffffffffff82111715611d1457611d14611b07565b60405280613600840185811115611d2a57600080fd5b845b81811015611cbc57611d3e8782611c52565b835260209092019161010001611d2c565b803560ff81168114610dcb57600080fd5b60006137608284031215611d7357600080fd5b611d7b611b1d565b9050813567ffffffffffffffff80821115611d9557600080fd5b908301906101a08286031215611daa57600080fd5b611db2611b46565b611dbc8684611c52565b8152611dcb6101008401611cc7565b60208201526101208084013583811115611de457600080fd5b611df088828701611b69565b60408401525061014084013560608301526101608401356080830152611e196101808501611c3e565b60a0830152818552611e2e8760208801611c52565b6020860152611e3f87828801611cdf565b604086015250505050611e556137208301611d4f565b6060820152611e676137408301611c3e565b608082015292915050565b60008060408385031215611e8557600080fd5b823567ffffffffffffffff80821115611e9d57600080fd5b611ea986838701611d60565b93506020850135915080821115611ebf57600080fd5b50611ecc85828601611b69565b9150509250929050565b600060208284031215611ee857600080fd5b813567ffffffffffffffff811115611eff57600080fd5b61045e84828501611d60565b60008060408385031215611f1e57600080fd5b823567ffffffffffffffff811115611f3557600080fd5b611f4185828601611b69565b95602094909401359450505050565b634e487b7160e01b600052601160045260246000fd5b600067ffffffffffffffff808316818516808303821115611f8957611f89611f50565b01949350505050565b600082821015611fa457611fa4611f50565b500390565b60008219821115611fbc57611fbc611f50565b500190565b6000600019821415611fd557611fd5611f50565b5060010190565b6000816000190483118215151615611ff657611ff6611f50565b500290565b634e487b7160e01b600052603260045260246000fd5b600063ffffffff808316818516808303821115611f8957611f89611f50565b600063ffffffff8381169083168181101561204d5761204d611f50565b039392505050565b634e487b7160e01b600052601260045260246000fd5b60008261207a5761207a612055565b500490565b600063ffffffff808316818516818304811182151516156120a2576120a2611f50565b02949350505050565b600063ffffffff808316818114156120c5576120c5611f50565b6001019392505050565b6000826120de576120de612055565b500690565b600060ff821660ff8416808210156120fd576120fd611f50565b90039392505050565b600060ff821660ff84168060ff0382111561212357612123611f50565b019392505050565b600181815b8085111561216657816000190482111561214c5761214c611f50565b8085161561215957918102915b93841c9390800290612130565b509250929050565b60008261217d57506001610372565b8161218a57506000610372565b81600181146121a057600281146121aa576121c6565b6001915050610372565b60ff8411156121bb576121bb611f50565b50506001821b610372565b5060208310610133831016604e8410600b84101617156121e9575081810a610372565b6121f3838361212b565b806000190482111561220757612207611f50565b029392505050565b6000610273838361216e56fea164736f6c6343000809000a",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "new_hasher()": {
        "notice": "Construct a new `Hasher` for the regular hash function."
      },
      "new_keyed(bytes)": {
        "notice": "Construct a new `Hasher` for the keyed hash function."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}