{
  "language": "Solidity",
  "sources": {
    "contracts/Blake3SolTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.9;\r\n\r\n// import \"./Blake3Sol.sol\";\r\n\r\ncontract Blake3SolTest {\r\n    // using Blake3Sol for Blake3Sol.Hasher;\r\n      //type State is uint32[16];\r\n    //type usize is uint32;\r\n    uint256 constant BLOCK_LEN = 64;\r\n    uint32 constant OUT_LEN = 32;\r\n    uint32 constant CHUNK_LEN = 1024;\r\n\r\n    // Flag constants\r\n    uint32 constant CHUNK_START = 1 << 0;\r\n    uint32 constant CHUNK_END = 1 << 1;\r\n    uint32 constant PARENT = 1 << 2;\r\n    uint32 constant ROOT = 1 << 3;\r\n    uint32 constant KEYED_HASH = 1 << 4;\r\n    uint32 constant DERIVE_KEY_CONTEXT = 1 << 5;\r\n    uint32 constant DERIVE_KEY_MATERIAL = 1 << 6;\r\n\r\n    // Product of a ChunkState before deriving chain value\r\n    struct Output {\r\n        uint32[8] input_chaining_value;\r\n        uint32[16] block_words;\r\n        uint64 counter;\r\n        uint256 block_len;\r\n        uint32 flags;\r\n    }\r\n\r\n    struct ChunkState {\r\n        uint32[8] chaining_value;\r\n        uint64 chunk_counter;\r\n        // Has a max size of BLOCK_LEN\r\n        bytes block_bytes;\r\n        uint256 block_len;\r\n        uint256 blocks_compressed;\r\n        uint32 flags;\r\n    }\r\n\r\n    // An incremental hasher that can accept any number of writes.\r\n    struct Hasher {\r\n        ChunkState chunk_state;\r\n        uint32[8] key_words;\r\n        uint32[8][54] cv_stack; // Space for 54 subtree chaining values:\r\n        uint8 cv_stack_len;     // 2^54 * CHUNK_LEN = 2^64\r\n        uint32 flags;\r\n    }\r\n\r\n    function test_hash() public pure returns (bytes memory) {\r\n        Hasher memory hasher = new_hasher();\r\n\r\n        hasher = update_hasher(hasher, unicode\"hellohello?\");\r\n        bytes memory output = finalize(hasher);\r\n\r\n        return output;\r\n\r\n        // assertEq(\r\n        //     bytes32(output),\r\n        //     0x10e6acb2cfcc4bb07588ad5b8e85f6a13f19e24f3302826effd93ce1ebbece6e\r\n        // );\r\n    }\r\n\r\n    function test_keyed_hash() public pure returns (bytes memory) {\r\n        Hasher memory hasher  = new_keyed(unicode\"hellohello!\");\r\n\r\n        hasher = update_hasher(hasher, unicode\"hellohello?\");\r\n        bytes memory output = finalize(hasher);\r\n\r\n        return output;\r\n\r\n        // assertEq(\r\n        //     bytes32(output),\r\n        //     0x0edd7e645d2bc1bba1f323f6339a3d0448ec6b675991e8dc76d2396eb0dffca2\r\n        // );\r\n    }\r\n\r\n    function test_keyed_hash_ten_times() public pure returns (bytes memory) {\r\n        Hasher memory hasher  = new_keyed(unicode\"hellohello!\");\r\n        bytes memory output;\r\n\r\n        for (uint256 i = 0; i < 10; ++i) {\r\n            hasher = update_hasher(hasher, unicode\"hellohello?\");\r\n            output = finalize(hasher);\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    /**\r\n    * This test works by levaraging the FFI provided by Foundry tools, but it also requires the\r\n    * bridge-differential-tests project to exist in the same folder as Blake3Sol and it must\r\n    * be compiled using `cargo build` before running the Solidity test. This test currently passes\r\n    * hashing ~50kb of data.\r\n    *\r\n    function test_big_hash_ffi() public {\r\n        string[] memory cmds = new string[](2);\r\n        cmds[0] = '../bridge-differential-tests/target/debug/bridge_differential_tests';\r\n        cmds[1] = '--big-hash';\r\n\r\n        bytes memory packedData = vm.ffi(cmds);\r\n        (bytes memory data, bytes32 dataHash) = abi.decode(packedData, (bytes, bytes32));\r\n\r\n        Blake3Sol.Hasher memory hasher = Blake3Sol.new_keyed(\r\n            abi.encodePacked(\r\n                bytes32(0xc811f2ef6eb6bd09fb973c747cbf349e682393ca4d8df88e5f0bcd564c10a84b)\r\n            )\r\n        );\r\n        hasher = hasher.update_hasher(data);\r\n        bytes memory bigHash = hasher.finalize();\r\n\r\n        assertEq(bytes32(bigHash), dataHash);\r\n    }\r\n    */\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n      // This should remain constant but solidity doesn't support declaring it\r\n    // uint8[16] MSG_PERMUTATION = [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8];\r\n    // uint32[8] IV = [\r\n    //     0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\r\n    // ];\r\n    function _MSG_PERMUTATION() internal pure returns (uint8[16] memory) {\r\n        return [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8];\r\n    }\r\n\r\n    function _IV() internal pure returns (uint32[8] memory) {\r\n        return [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19];\r\n    }\r\n\r\n    // Mixing function G\r\n    function _g(\r\n        uint32[16] memory state,\r\n        uint32 a,\r\n        uint32 b,\r\n        uint32 c,\r\n        uint32 d,\r\n        uint32 mx,\r\n        uint32 my\r\n    ) internal pure {\r\n        unchecked {\r\n            state[a] = state[a] + state[b] + mx;\r\n            state[d] = _rotr(state[d] ^ state[a], 16);\r\n            state[c] = state[c] + state[d];\r\n            state[b] = _rotr(state[b] ^ state[c], 12);\r\n            state[a] = state[a] + state[b] + my;\r\n            state[d] = _rotr(state[d] ^ state[a], 8);\r\n            state[c] = state[c] + state[d];\r\n            state[b] = _rotr(state[b] ^ state[c], 7);\r\n        }\r\n    }\r\n\r\n    function _round(uint32[16] memory state, uint32[16] memory m) internal pure {\r\n        // Mix the columns.\r\n        _g(state, 0, 4, 8, 12, m[0], m[1]);\r\n        _g(state, 1, 5, 9, 13, m[2], m[3]);\r\n        _g(state, 2, 6, 10, 14, m[4], m[5]);\r\n        _g(state, 3, 7, 11, 15, m[6], m[7]);\r\n\r\n        // Mix the diagonals.\r\n        _g(state, 0, 5, 10, 15, m[8], m[9]);\r\n        _g(state, 1, 6, 11, 12, m[10], m[11]);\r\n        _g(state, 2, 7, 8, 13, m[12], m[13]);\r\n        _g(state, 3, 4, 9, 14, m[14], m[15]);\r\n    }\r\n\r\n    function _permute(uint32[16] memory m) internal pure {\r\n        uint8[16] memory MSG_PERMUTATION = _MSG_PERMUTATION();\r\n        uint32[16] memory permuted;\r\n\r\n        for (uint256 i = 0; i < 16; ++i) {\r\n            permuted[i] = m[MSG_PERMUTATION[i]];\r\n        }\r\n\r\n        for (uint256 i = 0; i < 16; ++i) {\r\n            m[i] = permuted[i];\r\n        }\r\n    }\r\n\r\n    function _compress(\r\n        uint32[8] memory chaining_value,\r\n        uint32[16] memory block_words_ref,\r\n        uint64 counter,\r\n        uint256 block_len,\r\n        uint32 flags\r\n    ) internal pure returns (uint32[16] memory) {\r\n        uint32[8] memory IV = _IV();\r\n        uint32[16] memory block_words;\r\n        for (uint256 i = 0; i < 16; ++i) {\r\n            block_words[i] = block_words_ref[i];\r\n        }\r\n\r\n        uint32[16] memory state = [\r\n            chaining_value[0],\r\n            chaining_value[1],\r\n            chaining_value[2],\r\n            chaining_value[3],\r\n            chaining_value[4],\r\n            chaining_value[5],\r\n            chaining_value[6],\r\n            chaining_value[7],\r\n            IV[0],\r\n            IV[1],\r\n            IV[2],\r\n            IV[3],\r\n            uint32(counter),\r\n            uint32(counter >> 32),\r\n            ///////////////////////////////\r\n            uint32(block_len),\r\n            flags\r\n        ];\r\n\r\n\r\n        _round(state, block_words); // round 1\r\n        _permute(block_words);\r\n        _round(state, block_words); // round 2\r\n        _permute(block_words);\r\n        _round(state, block_words); // round 3\r\n        _permute(block_words);\r\n        _round(state, block_words); // round 4\r\n        _permute(block_words);\r\n        _round(state, block_words); // round 5\r\n        _permute(block_words);\r\n        _round(state, block_words); // round 6\r\n        _permute(block_words);\r\n        _round(state, block_words); // round 7\r\n\r\n        for (uint256 i = 0; i < 8; ++i) {\r\n            state[i] ^= state[i + 8];\r\n            state[i + 8] ^= chaining_value[i];\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    function _rotr(uint32 x, uint8 n) internal pure returns (uint32) {\r\n        bytes4 b = bytes4(x);\r\n        return uint32((b >> n) | (b << (32 - n)));\r\n    }\r\n\r\n    function _chaining_value(Output memory o) internal pure returns (uint32[8] memory) {\r\n        uint32[16] memory compression_output = _compress(\r\n            o.input_chaining_value,\r\n            o.block_words,\r\n            o.counter,\r\n            o.block_len,\r\n            o.flags\r\n        );\r\n\r\n        return _first_8_words(compression_output);\r\n    }\r\n\r\n    function _root_output_bytes(\r\n        Output memory self,\r\n        bytes memory out_slice\r\n    ) internal pure {\r\n        //uint32 output_block_counter = 0;\r\n        // Take 64-byte chunks at a time from out_slice\r\n        //for (uint32 i = 0; i < out_slice.length; i += 2 * OUT_LEN) {\r\n        uint32[16] memory words = _compress(\r\n            self.input_chaining_value,\r\n            self.block_words,\r\n            0,\r\n            //output_block_counter,\r\n            self.block_len,\r\n            self.flags | ROOT\r\n        );\r\n\r\n        // Load compressed words into out_slice (4 bytes at a time)\r\n        // The output length might not be a multiple of 4.\r\n        //for (uint32 j = 0; j < words.length && out_slice.length > j*4; j++) {\r\n        //for (uint32 j = 0; j < words.length; j++) {\r\n        for (uint32 j = 0; j < 8; j++) {\r\n            // Load word at j into out_slice as little endian\r\n            _load_uint32_to_le_bytes(words[j], out_slice, j*4);\r\n        }\r\n\r\n            //output_block_counter += 1;\r\n        //}\r\n    }\r\n\r\n    function _load_uint32_to_le_bytes(\r\n        uint32 n,\r\n        bytes memory buf,\r\n        uint32 offset\r\n    ) internal pure {\r\n        for (uint256 i = 0; i < 4; ++i) {\r\n            buf[offset+i] = bytes1(uint8(n / (2 ** (i*8))));\r\n        }\r\n    }\r\n\r\n    function _uint32_to_le_bytes(uint32 n) internal pure returns (bytes4) {\r\n        bytes4 buf;\r\n        for (uint256 i = 0; i < 4; ++i) {\r\n            assembly {\r\n                let cc := add(buf, 0x20)\r\n                let buf_idx := add(cc, sub(3, i))\r\n                let n_idx := add(n, i)\r\n                mstore8(buf_idx, n_idx)\r\n            }\r\n        }\r\n\r\n        return buf;\r\n    }\r\n\r\n\r\n    function _le_bytes_get_uint32(bytes memory _bytes, uint256 _start) public pure returns (uint32) {\r\n        require(_bytes.length >= _start + 4, \"le_bytes_get_uint32_outOfBounds\");\r\n        uint32 tempUint;\r\n\r\n        for (uint256 i = 0; i < 4; ++i) {\r\n            //tempUint += uint32(uint8(_bytes[i]) * (2 ** (8*i)));\r\n            tempUint += uint32(bytes4(_bytes[3-i+_start]) >> (8 * i));\r\n        }\r\n        /*\r\n        assembly {\r\n            // TODO why is this 0x4 in the bytes library???\r\n            //tempUint := mload(add(add(_bytes, 0x4), _start))\r\n\r\n            // Load 32 bytes from array (u256)\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n            // Keep just the first 4 bytes (u32)\r\n            //tempUint := xor(tempUint, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000)\r\n            tempUint := xor(tempUint, 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n        */\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function _words_from_little_endian_bytes8(\r\n        bytes memory data_bytes,\r\n        uint32[8] memory words\r\n    ) internal pure {\r\n        require(data_bytes.length <= 4*8,\r\n                \"Data bytes is too long to convert to 8 4-byte words\");\r\n\r\n        for (uint256 i = 0; i < data_bytes.length/4; ++i) {\r\n            words[i] = _le_bytes_get_uint32(data_bytes, i*4);\r\n        }\r\n    }\r\n\r\n    function _words_from_little_endian_bytes(\r\n        bytes memory data_bytes,\r\n        uint32[16] memory words\r\n    ) internal pure {\r\n        require(data_bytes.length <= 64 && data_bytes.length%4 == 0,\r\n                \"Data bytes is too long to convert to 16 4-byte words\");\r\n\r\n        for (uint256 i = 0; i < data_bytes.length/4; ++i) {\r\n            words[i] = _le_bytes_get_uint32(data_bytes, i*4);\r\n        }\r\n    }\r\n\r\n\r\n    // TODO I wish this didn't require a copy to convert array sizes\r\n    function _first_8_words(uint32[16] memory words) internal pure returns (uint32[8] memory) {\r\n        // TODO there must be a way to do this without copying\r\n        // How to take a slice of a memory array?\r\n        uint32[8] memory first_8;\r\n        for (uint256 i = 0; i < 8; ++i) {\r\n            first_8[i] = words[i];\r\n        }\r\n\r\n        return first_8;\r\n    }\r\n\r\n\r\n    //\r\n    // Chunk state functions\r\n    //\r\n\r\n    function _new_chunkstate(\r\n        uint32[8] memory key_words,\r\n        uint64 chunk_counter,\r\n        uint32 flags\r\n    ) internal pure returns (ChunkState memory) {\r\n        bytes memory block_bytes = new bytes(BLOCK_LEN);\r\n        return ChunkState({\r\n            chaining_value: key_words,\r\n            chunk_counter: chunk_counter,\r\n            block_bytes: block_bytes,\r\n            block_len: 0,\r\n            blocks_compressed: 0,\r\n            flags: flags\r\n        });\r\n    }\r\n\r\n    function _len(ChunkState memory chunk) internal pure returns (uint256) {\r\n        return BLOCK_LEN * chunk.blocks_compressed + chunk.block_len;\r\n    }\r\n\r\n    function _start_flag(ChunkState memory chunk) internal pure returns (uint32) {\r\n        if (chunk.blocks_compressed == 0) {\r\n            return CHUNK_START;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // Returns a new input offset\r\n    function _update_chunkstate(\r\n        ChunkState memory chunk,\r\n        bytes memory input\r\n    ) internal pure {//returns (uint32) {\r\n        uint256 input_offset = 0;\r\n        while (input_offset < input.length) {\r\n            // If the block buffer is full, compress it and clear it. More\r\n            // input is coming, so this compression is not CHUNK_END.\r\n            if (chunk.block_len == BLOCK_LEN) {\r\n                uint32[16] memory block_words;\r\n                _words_from_little_endian_bytes(chunk.block_bytes, block_words);\r\n                chunk.chaining_value = _first_8_words(_compress(\r\n                    chunk.chaining_value,\r\n                    block_words,\r\n                    chunk.chunk_counter,\r\n                    BLOCK_LEN,\r\n                    chunk.flags | _start_flag(chunk)\r\n                ));\r\n                chunk.blocks_compressed += 1;\r\n                // TODO probably cheaper to zero-out byte array than to reallocate\r\n                chunk.block_bytes = new bytes(BLOCK_LEN);\r\n                chunk.block_len = 0;\r\n            }\r\n\r\n            // Take enough to fill a block [min(want, input.length)]\r\n            uint256 want = BLOCK_LEN - chunk.block_len;\r\n            uint256 take = _min(want, input.length - input_offset);\r\n\r\n            // Copy bytes from input to chunk block\r\n            //chunk.block_bytes[self.block_len as usize..][..take].copy_from_slice(&input[..take]);\r\n            for (uint256 i = 0; i < take; ++i) {\r\n                // TODO recheck this logic\r\n                chunk.block_bytes[i+chunk.block_len] = input[input_offset+i];\r\n            }\r\n            /*\r\n            bytes memory block_ref = chunk.block_bytes;\r\n            uint32 blen = chunk.block_len;\r\n            assembly {\r\n                let block_addr := add(add(block_ref, 0x20), blen)\r\n                let input_addr := add(add(input.offset, 0x20), input_offset)\r\n                memorycopy(block_addr, input_addr, take)\r\n            }\r\n            */\r\n\r\n            chunk.block_len += take;\r\n            input_offset += take;\r\n        }\r\n    }\r\n\r\n    function _min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (x < y) {\r\n            return x;\r\n        } else {\r\n            return y;\r\n        }\r\n    }\r\n\r\n    function _output(ChunkState memory chunk) internal pure returns (Output memory) {\r\n        uint32[16] memory block_words;\r\n        _words_from_little_endian_bytes(chunk.block_bytes, block_words);\r\n\r\n        return Output({\r\n            input_chaining_value: chunk.chaining_value,\r\n            block_words: block_words,\r\n            counter: chunk.chunk_counter,\r\n            block_len: chunk.block_len,\r\n            flags: chunk.flags | _start_flag(chunk) | CHUNK_END\r\n        });\r\n    }\r\n\r\n    //\r\n    // Parent functions\r\n    //\r\n\r\n    function _parent_output(\r\n        uint32[8] memory left_child_cv,\r\n        uint32[8] memory right_child_cv,\r\n        uint32[8] memory key_words,\r\n        uint32 flags\r\n    ) internal pure returns (Output memory) {\r\n        uint32[16] memory block_words;\r\n\r\n        for (uint256 i = 0; i < 8; ++i) {\r\n            block_words[i] = left_child_cv[i];\r\n        }\r\n\r\n        for (uint256 i = 8; i < 16; ++i) {\r\n            block_words[i] = right_child_cv[i - 8];\r\n        }\r\n\r\n        return Output({\r\n            input_chaining_value: key_words,\r\n            block_words: block_words,\r\n            counter: 0,           // Always 0 for parent nodes.\r\n            block_len: BLOCK_LEN, // Always BLOCK_LEN (64) for parent nodes.\r\n            flags: PARENT | flags\r\n        });\r\n    }\r\n\r\n    function _parent_cv(\r\n        uint32[8] memory left_child_cv,\r\n        uint32[8] memory right_child_cv,\r\n        uint32[8] memory key_words,\r\n        uint32 flags\r\n    ) internal pure returns (uint32[8] memory) {\r\n        return _chaining_value(_parent_output(left_child_cv, right_child_cv, key_words, flags));\r\n    }\r\n\r\n\r\n    //\r\n    // Hasher functions\r\n    //\r\n\r\n    function _new_hasher_internal(\r\n        uint32[8] memory key_words, uint32 flags\r\n    ) internal pure returns (Hasher memory) {\r\n        uint32[8][54] memory cv_stack;\r\n        return Hasher({\r\n            chunk_state: _new_chunkstate(key_words, 0, flags),\r\n            key_words: key_words,\r\n            cv_stack: cv_stack,\r\n            cv_stack_len: 0,\r\n            flags: flags\r\n        });\r\n    }\r\n\r\n    /// Construct a new `Hasher` for the regular hash function.\r\n    function new_hasher() public pure returns (Hasher memory) {\r\n        uint32[8] memory IV = _IV();\r\n        return _new_hasher_internal(IV, 0);\r\n    }\r\n\r\n    /// Construct a new `Hasher` for the keyed hash function.\r\n    function new_keyed(bytes memory key) public pure returns (Hasher memory) {\r\n        uint32[8] memory key_words;\r\n        bytes memory key_mem = key;\r\n        _words_from_little_endian_bytes8(key_mem, key_words);\r\n        return _new_hasher_internal(key_words, KEYED_HASH);\r\n    }\r\n\r\n    // Construct a new `Hasher` for the key derivation function. The context\r\n    // string should be hardcoded, globally unique, and application-specific\r\n    function new_derive_key(bytes memory context) public pure returns (Hasher memory) {\r\n        uint32[8] memory IV = _IV();\r\n        Hasher memory context_hasher = _new_hasher_internal(IV, DERIVE_KEY_CONTEXT);\r\n        update_hasher(context_hasher, context);\r\n\r\n        bytes memory context_key = new bytes(256);\r\n        _finalize_internal(context_hasher, context_key);\r\n\r\n        uint32[8] memory context_key_words;\r\n        _words_from_little_endian_bytes8(context_key, context_key_words);\r\n\r\n        return _new_hasher_internal(context_key_words, DERIVE_KEY_MATERIAL);\r\n    }\r\n\r\n    function _push_stack(Hasher memory self, uint32[8] memory cv) internal pure {\r\n        self.cv_stack[self.cv_stack_len] = cv;\r\n        self.cv_stack_len += 1;\r\n    }\r\n\r\n    function _pop_stack(Hasher memory self) internal pure returns (uint32[8] memory) {\r\n        self.cv_stack_len -= 1;\r\n        return self.cv_stack[self.cv_stack_len];\r\n    }\r\n\r\n    function _add_chunk_chaining_value(\r\n        Hasher memory self,\r\n        uint32[8] memory new_cv,\r\n        uint64 total_chunks\r\n    ) internal pure {\r\n        while (total_chunks & 1 == 0) {\r\n            new_cv = _parent_cv(_pop_stack(self), new_cv, self.key_words, self.flags);\r\n            total_chunks >>= 1;\r\n        }\r\n\r\n        _push_stack(self, new_cv);\r\n    }\r\n\r\n    function _slice(\r\n        bytes memory data,\r\n        uint256 start,\r\n        uint256 end\r\n    ) internal pure returns (bytes memory) {\r\n        uint256 dataSliceLength = end - start;\r\n        bytes memory dataSlice = new bytes(dataSliceLength);\r\n\r\n        for (uint256 i = 0; i < dataSliceLength; ++i) {\r\n            dataSlice[i] = data[start + i];\r\n        }\r\n\r\n        return dataSlice;\r\n    }\r\n\r\n    // Add input to the hash state. This can be called any number of times.\r\n    function update_hasher(\r\n        Hasher memory self, bytes memory input\r\n    ) public pure returns (Hasher memory) {\r\n        uint256 input_offset = 0;\r\n\r\n        while (input_offset < input.length) {\r\n            // If the current chunk is complete, finalize it and reset the\r\n            // chunk state. More input is coming, so this chunk is not ROOT.\r\n                if (_len(self.chunk_state) == CHUNK_LEN) {\r\n                uint32[8] memory chunk_cv = _chaining_value(_output(self.chunk_state));\r\n                uint64 total_chunks = self.chunk_state.chunk_counter + 1;\r\n\r\n                _add_chunk_chaining_value(self, chunk_cv, total_chunks);\r\n\r\n                self.chunk_state = _new_chunkstate(self.key_words, total_chunks, self.flags);\r\n            }\r\n\r\n            // Compress input bytes into the current chunk state.\r\n            uint256 want = CHUNK_LEN - _len(self.chunk_state);\r\n            uint256 take = _min(want, uint32(input.length - input_offset));\r\n\r\n            // Update chunk state\r\n            bytes memory input_slice = _slice(input, input_offset, take + input_offset);\r\n            _update_chunkstate(self.chunk_state, input_slice);\r\n\r\n            input_offset += take;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    function finalize(Hasher memory self) public pure returns (bytes memory) {\r\n        bytes memory output = new bytes(32);\r\n\r\n        _finalize_internal(self, output);\r\n\r\n        return output;\r\n    }\r\n\r\n    function _finalize_internal(\r\n        Hasher memory self, bytes memory out_slice\r\n    ) internal pure {\r\n        // Starting with the Output from the current chunk, compute all the\r\n        // parent chaining values along the right edge of the tree, until we\r\n        // have the root Output.\r\n        Output memory output = _output(self.chunk_state);\r\n        uint32 parent_nodes_remaining = self.cv_stack_len;\r\n\r\n        while (parent_nodes_remaining > 0) {\r\n            parent_nodes_remaining -= 1;\r\n\r\n            output = _parent_output(\r\n                self.cv_stack[parent_nodes_remaining],\r\n                _chaining_value(output),\r\n                self.key_words,\r\n                self.flags\r\n            );\r\n        }\r\n        _root_output_bytes(output, out_slice);\r\n    }\r\n}"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}